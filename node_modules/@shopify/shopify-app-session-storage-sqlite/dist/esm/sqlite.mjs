import { Session } from '@shopify/shopify-api';
import { SqliteConnection } from './sqlite-connection.mjs';
import { migrationList } from './migrations.mjs';
import { SqliteSessionStorageMigrator } from './sqlite-migrator.mjs';

const defaultSQLiteSessionStorageOptions = {
    sessionTableName: 'shopify_sessions',
    migratorOptions: {
        migrationDBIdentifier: 'shopify_sessions_migrations',
        migrationNameColumnName: 'migration_name',
    },
};
class SQLiteSessionStorage {
    constructor(database, opts = {}) {
        this.options = { ...defaultSQLiteSessionStorageOptions, ...opts };
        this.db = new SqliteConnection(database, this.options.sessionTableName);
        this.internalInit = this.init();
        this.migrator = new SqliteSessionStorageMigrator(this.db, this.options.migratorOptions, migrationList);
        this.ready = this.migrator.applyMigrations(this.internalInit);
    }
    async storeSession(session) {
        await this.ready;
        // Note milliseconds to seconds conversion for `expires` property
        const entries = session
            .toPropertyArray()
            .map(([key, value]) => key === 'expires'
            ? [key, Math.floor(value / 1000)]
            : [key, value]);
        const query = `
      INSERT OR REPLACE INTO ${this.options.sessionTableName}
      (${entries.map(([key]) => key).join(', ')})
      VALUES (${entries
            .map(() => `${this.db.getArgumentPlaceholder()}`)
            .join(', ')});
    `;
        await this.db.query(query, entries.map(([_key, value]) => value));
        return true;
    }
    async loadSession(id) {
        await this.ready;
        const query = `
      SELECT * FROM ${this.options.sessionTableName}
      WHERE id = ${this.db.getArgumentPlaceholder()};
    `;
        const rows = await this.db.query(query, [id]);
        if (!Array.isArray(rows) || rows?.length !== 1)
            return undefined;
        const rawResult = rows[0];
        return this.databaseRowToSession(rawResult);
    }
    async deleteSession(id) {
        await this.ready;
        const query = `
      DELETE FROM ${this.options.sessionTableName}
      WHERE id = ${this.db.getArgumentPlaceholder()};
    `;
        await this.db.query(query, [id]);
        return true;
    }
    async deleteSessions(ids) {
        await this.ready;
        const query = `
      DELETE FROM ${this.options.sessionTableName}
      WHERE id IN (${ids
            .map(() => `${this.db.getArgumentPlaceholder()}`)
            .join(',')});
    `;
        await this.db.query(query, ids);
        return true;
    }
    async findSessionsByShop(shop) {
        await this.ready;
        const query = `
      SELECT * FROM ${this.options.sessionTableName}
      WHERE shop = ${this.db.getArgumentPlaceholder()};
    `;
        const rows = await this.db.query(query, [shop]);
        if (!Array.isArray(rows) || rows?.length === 0)
            return [];
        const results = rows.map((row) => {
            return this.databaseRowToSession(row);
        });
        return results;
    }
    async init() {
        const hasSessionTable = await this.db.hasTable(this.options.sessionTableName);
        if (!hasSessionTable) {
            const query = `
        CREATE TABLE ${this.options.sessionTableName} (
          id varchar(255) NOT NULL PRIMARY KEY,
          shop varchar(255) NOT NULL,
          state varchar(255) NOT NULL,
          isOnline integer NOT NULL,
          expires integer,
          scope varchar(1024),
          accessToken varchar(255),
          onlineAccessInfo varchar(255)
        );
      `;
            await this.db.query(query);
        }
    }
    databaseRowToSession(row) {
        // convert seconds to milliseconds prior to creating Session object
        if (row.expires)
            row.expires *= 1000;
        return Session.fromPropertyArray(Object.entries(row));
    }
}

export { SQLiteSessionStorage };
//# sourceMappingURL=sqlite.mjs.map
